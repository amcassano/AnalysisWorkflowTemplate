---
title: "Analysis Workflow"
author: "Alexandra Cassano"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: tibble
    highlight: tango
    theme: united
    toc: yes
    toc_float:
        collapsed: true
  pdf_document:
    number_sections: yes
    keep_tex: yes
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

-   This code should be usable to analyze your bulk RNA-seq data.

-   **Please read through the document before making any changes. This is a template and will indicate where you need to make changes for your specific experiment.**

-   This R markdown file is broken down into "code chunks" that can be run individually.

    -   Downstream chunks rely on upstream chunks so running code out of order is not recommended.

    -   In R Studio, you can run a chunk by hitting the "play button (▶️)" on the top right of the chunk.

    -   You can run all upstream chunks by clicking the button that has a down arrow pointing to a green bar.

-   I've tried to include handy-dandy tables throughout this template to describe the inputs you need to provide for the functions I've written.
    The functions all also have R documentation attached to them.
    In R studio if you put your mouse cursor on the function name and hit F1 it should pop up the help information for the function.
    Alternatively, click on the function name and use the toolbar.
    Click the 'Code' tab then find 'Go to Help'.

## \*\* If you aren't sure what inputs you should use for a given function check out the help page. You can access this by putting you cursor within a function name and hitting F1 or going to the code menu in the toolbar and clicking "Go to Help". \*\*

*Built with R version 4.3.2. Most recent template changes made on May 30, 2024*

# Prepare work-space

First you have to set up the "work-space" so that your computer knows what code it will need to import and where all of the raw data is.
This will also get everything set up in the right format for downstream code.

## Install Packages

This segment of code should only be run if the packages are not already installed on whichever computer this is being run on.
In order to have this chunk run, hit the run chunk button.
If you're running chunk by chunk be sure to run this chunk the first time but do not run this code subsequent times.
All of the functions from the `analyzeRNA` package (and all functions generally) has a help page that I've written for them.

[**Do not edit this chunk (just hit the run chunk button if needed)**]{style="color: red"}

```{r install_pkgs, eval=FALSE, message=FALSE}
install.packages("BiocManager")
install.packages("tidyverse")
install.packages("ggplot2")
install.packages("ggrepel")
install.packages("stringi")
install.packages("pheatmap")
install.packages("stats")
install.packages("devtools")
install.packages("RColorBrewer")
install.packages("ggalt")
install.packages("ggpubr")
install.packages("ggridges")
install.packages("ggupset")
install.packages("limma")
install.packages("ggVennDiagram")
install.packages("knitr")
install.packages("paleteer")
install.packages("purrr")
install.packages("roxygen2")
BiocManager::install("enrichplot")
BiocManager::install("BiocGenerics")
BiocManager::install("DESeq2")
BiocManager::install("GO.db")
BiocManager::install("GOstats")
BiocManager::install("pathview")
BiocManager::install("gage")
BiocManager::install("uwot")
BiocManager::install("gageData")
BiocManager::install("GenomicRanges")
BiocManager::install("Repitools")
BiocManager::install("clusterProfiler")
BiocManager::install("org.Mm.eg.db")
BiocManager::install("DOSE")
BiocManager::install("pathview")
BiocManager::install("treemap")
BiocManager::install("biomaRt")
BiocManager::install("rrvgo")
BiocManager::install("PCAtools")

devtools::install_github("JamesJoly/DGSEA")
devtools::install_github("amcassano/RNAseqAnalysisPackage", upgrade = FALSE)
```

## Load packages

Packages need to be loaded every time you run the code.
Run this chunk every time you open a new R session.
These will be used for data manipulation, analysis, and visualization.
Leave this chunk as `eval=TRUE`

[**Do not edit this chunk**]{style="color: red"}

```{r load_pkgs, eval=TRUE, message=FALSE}
library(devtools)
library(roxygen2)
library(tidyverse)
library(utils)
library(stringi)
library(knitr)
library(rmarkdown)
library(ggplot2)
library(ggrepel)
library(ggalt)
library(org.Mm.eg.db)
library(biomaRt)
library(DESeq2)
library(RColorBrewer)
library(uwot)
library(ggVennDiagram)
library(pheatmap)
library(tinytex)
library(stats)
library(enrichplot)
library(clusterProfiler)
library(limma)
library(DOSE)
library(org.Mm.eg.db)
library(ggpubr)
library(treemap)
library(pathview)
library(PCAtools)
library(PERMANOVA)
library(DGSEA)
library(analyzeRNA) # arguably the most important line of code, this imports all the code I wrote
```

## Set working directory

This chunk will set the 'current working directory'.
You must change this to reflect what folder you'll be working in.
The working directory is all where all outputs will be saved.
All files being imported should also be in this folder.

Your working directory should contain:

1.  A folder called `raw_input` that has 1. CSV file containing all of the raw read counts obtained from the fastq files 2. CSV file containing the meta-data for your experiment
2.  A folder called `gene_lists` that has CSV files with any gene sets of interest
3.  this R markdown file

[**Change the working directory variable (change what is in the quotes) You will need to use the complete path. The path should end with the name of the folder, you should omit the trailing '/'**]{style="color: red"}

```{r workingdirectory, eval=TRUE}
# set working directory
primary_directory <- "parentfolder/childfolder/yourfolder"
setwd(primary_directory)

# this is the folder that contains your CSV files containing raw counts and your meta data CSV
raw_dir <- paste0(primary_directory, "/raw_input")
if (!dir.exists(raw_dir)) {
  dir.create(raw_dir)
}

# this is the folder that contains your CSV files that are lists of MGI symbols of interest
genelist_dir <- paste0(primary_directory, "/gene_lists")
if (!dir.exists(genelist_dir)) {
  dir.create(genelist_dir)
}

# this code will create an output directory for you if it doesnt exist. this is where exported analyses will be saved
output_dir <- paste0(primary_directory, "/analysis_outputs")
if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}
```

## Data import & preparation

### Import CSV files

-   The `raw_counts` variable is set as the csv file containing the output of feature counts after using STAR to align reads to the reference genome.
    The csv file must be "cleaned up" by removing unneeded columns such as *Chr*, *start*, *end* prior to loading into R.

-   The `meta` variable is set as the csv file containing metadata about the current experiment.
    At a minimum, it must contain sample names and conditions/groups.

    -   **The condition column must be named "Group" & the sample ID column must be named "SampleID".**

    -   You can also include other information such as sac day, cell type, or anything else you might want to keep track of, let me know if you do though so I can help with some minor code adjustments.

-   Samples not of interest (in a combined experiment, irrelevant groups) should be removed from both raw counts and metadata.

-   The samples **must** be in the same order in the `meta` file as they are in `raw_counts`.

-   Pre-filtering is applied to the raw data to remove any genes that have a total count number across samples less than the user defined minimum.
    Additionally, genes that have a total count that is less than a user defined value, when the single max count is subtracted are removed.
    This is done to filter out genes that have a high read count for just one sample, but are not expressed in other samples.
    These filtering steps minimize noise and remove outliers.

*Avoid using spaces, dashes, or other white space in the names of your files, use '\_' or CamelCase to separate words instead. Your file names must exactly match what you type below. Be sure to include the `.csv` file extension.*

[**Change`countsCSV` and `metadataCSV` file names**]{style="color: red"}

```{r import_data, eval=TRUE}
# import files
countsCSV <- "yourcountsfile.csv"
countsCSV <- paste(raw_dir, countsCSV, sep = "/")
raw_counts <- read.csv(countsCSV, header = TRUE, sep = ",")

metadataCSV <- "yourmetadatafile.csv"
metadataCSV <- paste(raw_dir, metadataCSV, sep = "/")
meta <- read.csv(metadataCSV, header = TRUE, sep = ",")
```

### CSV Cleanup

This code will accomplish a few things in order to get the files in the format needed for the rest of the code:

1.  Set the row names as the GeneID in the counts file

2.  Set groups as the data type `factor` :

    -   Replace whats in quotes with the names of your groups (add or remove lines as necessary). The contents of the `""` must *exactly* match the group as it is written in your metadata csv file. The order they appear is the order your groups will appear in plots and legends so fill in accordingly

3.  Apply pre-filtering to your data to retain only rows that have more than minimum counts across all samples.
    The more samples you have, the higher the number should be, the fewer samples you have the lower the number should be.
    It makes sense to set the number 300-1000.
    This is done to filter out genes that have a high read count for just one sample, but are not expressed in other samples.
    This minimizes noise and removes outliers.

[**Change the group names and count minimum**]{style="color: red"}

```{r csv_cleanup, eval=TRUE}
# renames each row as the GeneID and removes the Geneid column
rownames(raw_counts) <- raw_counts$Geneid
raw_counts <- dplyr::select(raw_counts, -Geneid)

# set groups as factors
meta$Group <- factor(meta$Group,
  levels = c(
    "group1",
    "group2",
    "group3",
    "group4",
    "group5",
    "group6"
  )
)

# pre-filtering
count_minimum <- 800

raw_counts$row_sum <- apply(raw_counts, 1, sum)
raw_counts <- raw_counts %>%
  dplyr::filter(row_sum > count_minimum) %>%
  dplyr::select(-c(row_sum))

# set the sample ID as the row name for the metadata
rownames(meta) <- meta$SampleID
meta <- meta %>% dplyr::select(-c(SampleID))
```

## Set colors, shapes, labels for plots

-   This code will set global variables for plotting such as the color palette, labels, and shapes.
    The aesthetics dataframe is created for use in creating consistent plots throughout.
    One of the package functions has the different options for the colors and shapes in it.

-   For colors you can choose from black, blue, orange, green, purple, red, yellow, brown, white, or grey.
    Fill the `""` with your choice, add or remove rows as necessary but make sure each row ends in a `,` except the last row.
    If you want a solid symbol make the fill and outline the same color.
    If you would like an open symbol set the fill as white.

-   For shapes you can choose from 'circle', 'crossed circle', 'diamond', 'crossed diamond', 'square', 'crossed square', 'triangle up', 'triangle down', 'x', 'plus', 'asterik'.
    Fill in the `""` (same concept as outline color)

-   For each group/condition you have you will specify the shape of symbol as well as the outline and fill colors desired.
    Each should be in the same order of the groups, the code below will also print out your options and the order of your groups.

[**Do not edit this chunk, just run it.**]{style="color: red"}

```{r global_aesthetics, eval=TRUE}
# get the names of the groups to assign to the colors/shapes
sample_labels <- (meta$Group)
group_labels <- unique(sample_labels) %>%
  sort() %>%
  print()

analyzeRNA::getPalettes()
```

[**Change the colors and shapes. Make sure that the number of arguments provided match the number of conditions you have. Add or remove lines from the `anno_colors` in the below format for the number of different conditions you have.**]{style="color: red"}

```{r set_aesthetics, eval=TRUE}
plot_aes <- analyzeRNA::set_aes(
  group_labels,
  c("shape1", "shape2", "shape3"),
  c("outline1", "outline2", "outline3"),
  c("fill1", "fill2", "fill3")
)

# for heatmaps - be sure to change group1 group2 etc to the names of your conditions
# make sure the order is correct
anno_colors <- list(
  Group = c(
    group1 = as.character(plot_aes$outlineID[1]),
    group2 = as.character(plot_aes$outlineID[2]),
    group3 = as.character(plot_aes$outlineID[3]),
    group4 = as.character(plot_aes$outlineID[4]),
    group5 = as.character(plot_aes$outlineID[5]),
    group6 = as.character(plot_aes$outlineID[6])
  )
)

# change the names here to match your conditions, make sure the order is correct
group1_color <- as.character(plot_aes$outlineID[1])
group2_color <- as.character(plot_aes$outlineID[2])
group3_color <- as.character(plot_aes$outlineID[3])

# change the names here to match your conditions, make sure hte order is correct
group1_shape <- as.numeric(plot_aes$shapeID[1])
group2_shape <- as.numeric(plot_aes$shapeID[2])
group3_shape <- as.numeric(plot_aes$shapeID[3])
```

------------------------------------------------------------------------

# Getting results: DEGs and Normalized Counts

Now that you've got everything set up, its time to start analysis!
The DESeq2 package has functions to find differentially expressed genes, statistics associated with this, and normalized counts.

First a DESeq data object is created using `raw_counts` and `meta`, specifying that `group` is the variable of interest in the metadata table.
The `DESeq` function is run and from this output, normalized results (rlog transformed, and normalized counts).

Differential gene expression requires pairwise comparisons, however analysis using the normalized counts (UMAP, PCA, Sample Distances) use all samples at once.

## Create DESeq object and run DESeq

-   This code will construct the `DESeqDataSet` which takes the raw counts and metadata as inputs.

-   `design = ~Group` means that Group is your experimental variable, this variable expresses how the counts for each gene depend on the variables in metadata.
    If the experimental design is more complex than just group (i.e. group and cell type) then you can combine variables (i.e. `~ Group + CellType`) (but lmk if this is the case as we might need to make some slight edits to the code).

-   DESeq uses a generalized linear model and outputs a DEseq2 object, we will use this to get normalized counts, p-values, and log-2 fold changes.

[**Only change this chunk if you need to change the experiment design**]{style="color: red"}

```{r DESeq2, eval=TRUE}
dseq <- analyzeRNA::getDESeq(raw_counts, meta, ~Group)
```

## Regularized Log Transformation (rLog)

-   This code will apply a regularized log transformation to the data.
    This transforms the count data to the log2 scale in a way which minimizes differences between samples for rows with small counts, and which normalizes with respect to library size.

-   The `rlogtransformation` produces a similar variance stabilizing effect as `varianceStabilizingTransformation`.
    rlog is more robust in the case when the size factors vary widely.
    The rlog transformation takes more time to calculate than the VST function but it is more robust.

-   The transformation is useful when checking for outliers or as input for machine learning techniques such as clustering or linear discriminant analysis.

-   rlog takes as input a `DESeqDataSet` and returns a `RangedSummarizedExperiment` object.
    We will also save this same information as a data frame.
    We need both for various parts of code below.

-   `blind = FALSE` must be included in the code.
    This determines whether to blind the transformation to the experimental design.
    `blind=TRUE` should be used for comparing samples in an manner unbiased by prior information on samples (for QC).
    `blind=FALSE` should be used for transforming data for downstream analysis, where the full use of the design information should be made.
    If many of genes have large differences in counts due to the experimental design, it is important to set `blind=FALSE` for downstream analysis.

[**Do not edit this chunk**]{style="color: red"}

```{r rlog_normalization, eval=TRUE}
rlog_norm <- DESeq2::rlog(dseq, blind = FALSE)
rlog_df <- as.data.frame(SummarizedExperiment::assay(rlog_norm))
```

## Pairwise comparisons

-   Multiple pairwise comparisons can be made to determine the differentially expressed genes for any 2 given groups.
    Pairwise comparisons between 2 specified groups are saved as objects for use further on.

-   You can choose to use a Log Fold Change shrinking algorithm.
    This mitigates the effects of any single sample on the log fold change calculations, minimizing noise.
    Add `log2FCshrink = TRUE` to the function call if you want to use this.
    The calculation used is the "ashr" algorithm (@stephens2016.)

-   **Pairwise comparison function inputs:**

    -   `numerator`-\> required; string; must match exactly as it's written in the DESeq object.
        If unsure run just the `print_group_names(dseq)` chunk of code.
        (ex: "Tolerant", "Naive")

    -   `denominator` -\> required; string; must match exactly as it's written in the DESeq object.
        If unsure run just the `print_group_names(dseq)` chunk of code.
        (ex: "Tolerant", "Naive")

    -   `dseq_obj` -\> required; DESeqObject; This is the DESeq object we saved two chunks above.
        Don't change the name of it unless you also changed the name in the above chunks.

    -   `contrast_str` -\> optional; string; defaults to `"Group"`; This will be indicate what is the independent variable in your data.
        If you set things up as I described above it should be Group.
        If not, you may need to specify Condition or something else like that.

    -   `tidy_result` -\> optional; boolean; defaults to `TRUE`; When set to TRUE the results will output as a nice dataframe.
        IDK why you'd want to change that.
        Odds are you'll leave it be

    -   `log2FCshrink` -\> optional; boolean; defaults to `FALSE`; If you've got a lot of variance going on in your data you might want to set this to TRUE.
        It will do some math to handle that.
        I don't understand the math but feel free to look it up if you care to.

[**Add the desired comparisons, change the names of the numerator and denominator and the names of the objects you're storing the results in.**]{style="color: red"}

```{r print_group_names}
analyzeRNA::print_group_names(dseq)
```

```{r degs, eval=TRUE}
one_vs_two <- analyzeRNA::pairwiseDEGresults(
  numerator = "comparisongroup",
  denominator = "baselinegroup",
  deseq_obj = dseq
)

two_vs_three <- analyzeRNA::pairwiseDEGresults(
  numerator = "othergroup",
  denominator = "anotherone",
  deseq_obj = dseq
)

one_vs_three <- analyzeRNA::pairwiseDEGresults(
  numerator = "comparisongroup",
  denominator = "anotherone",
  deseq_obj = dseq
)
```

The `pairwiseDEGresults` function calls the DESeq2 package's `results` function and removes any Genes that have a p-value of 'NA'.
According to the documentation \> "By default, independent filtering is performed to select a set of genes for multiple test correction which maximizes the number of adjusted p-values less than a given critical value alpha (by default 0.1). See the reference in this man page for details on independent filtering. The filter used for maximizing the number of rejections is the mean of normalized counts for all samples in the dataset. Several arguments from the filtered_p function of the genefilter package (used within the results function) are provided here to control the independent filtering behavior. (Note filtered_p R code is now copied into DESeq2 package to avoid gfortran requirements.) In DESeq2 version \>= 1.10, the threshold that is chosen is the lowest quantile of the filter for which the number of rejections is close to the peak of a curve fit to the number of rejections over the filter quantiles. 'Close to' is defined as within 1 residual standard deviation. The adjusted p-values for the genes which do not pass the filter threshold are set to NA. By default, results assigns a p-value of NA to genes containing count outliers, as identified using Cook's distance. See the cooksCutoff argument for control of this behavior. Cook's distances for each sample are accessible as a matrix "cooks" stored in the assays() list. This measure is useful for identifying rows where the observed counts might not fit to a Negative Binomial distribution."

Therefore, we will want to remove those same genes from the `rlog_df`.
The code below will accomplish this.
Change the name of the object `one_vs_two` to reflect one of your pairwise comparisons.
You only need to do this with one of your pairwise comparisons.
The genes that will have an NA P value will be the same for all comparisons.

```{r remove_NAs}
# only run this line once, if you run it more than once you will get an error message
rlog_df <- tibble::rownames_to_column(rlog_df, var = "GeneID")

# for this line of code the only thing you need to do is change `one_vs_two` to be one of your pairwise comparisons (doesn't matter which one)
rlog_df <- dplyr::filter(rlog_df, GeneID %in% one_vs_two$GeneID)
```

# Annotate Results

-   The initial `raw_counts` table, and therefore all DESeq results derived from it, use the *Ensembl ID* to identify each gene.
    However, this is not a useful identifier for most humans.

-   The BiomaRt package can be used to match the *Ensembl ID* with it's corresponding *MGI Symbol*, *MGI Description*, (and optionally things like the *Entrez (NCBI) ID* ).

-   The genemap can be altered to omit or include different attributes as needed.
    The genemap is then used along with a `deseq results object` in the `annotate_biomart()` function to add these descriptors to the results.

-   Any data frame that has *Ensembl ID*s in a column called `GeneID` can be used in this annotation function.
    This is required for using the annotation

## Make genemap

The genemap will create a data frame that includes all of the Ensembl Gene IDs in your entire data set and their corresponding MGI symbol and description.

[**Do not change (unless you want to add more things like EntrezID)**]{style="color: red"}

```{r make_genemap, eval=TRUE}
allgenes <- dplyr::select(rlog_df, GeneID)
gmap <- analyzeRNA::createGenemap(allgenes,
  GMattributes = c(
    "ensembl_gene_id",
    "mgi_symbol",
    "mgi_description"
  )
)

gmap_entrezid <- analyzeRNA::createGenemap(allgenes,
  GMattributes = c(
    "ensembl_gene_id",
    "mgi_symbol",
    "mgi_description",
    "entrezgene_id"
  )
)
# if you want entrez id  you'll need to adjust things further down to reflect that
# If you wnat to do KEGG analysis you will need the EntrezIDs, i would recommend creating 2 sets of  annotated dataframes for ease of future use
```

## Annotate pairwise comparisons (DEGs)

-   **annotation function inputs**
    -   `res` -\> required; dataframe; the results data frame generated earlier, must include `GeneID` column with the ensembl ID in it (ex. `rlog_df`, `one_vs_two`)
    -   `gm` -\> required; dataframe; the genemap generated using the above chunk
    -   `gmattri` -\> optional; list of strings; defaults to including just MGI symbol and description; Dictates which columns from the gene map are kept after renaming and reordering. Can't include a column not present in the genemap (ex. `c("MGI_Symbol", "GeneType", "EntrezID")`)

[**Add all of your pairwise comparisons, so all of your results get annotated**]{style="color: red"}

```{r annotate_rlog, eval=TRUE}
# if you also want to have entrez id dataframes just add them ABOVE the regular annotations.
# you must run these first because you'll save them to a different name but the regular annotation will overwrite the object
rlog_df_entrezid <- analyzeRNA::annotate_biomart(rlog_df,
  gmap_entrezid,
  gmattri = c("MGI_Symbol", "MGI_Desc", "EntrezID")
)

rlog_df <- analyzeRNA::annotate_biomart(rlog_df,
  gmap, # dont change this
  gmattri = c("MGI_Symbol", "MGI_Desc")
)
```

```{r annotate_degs, eval=TRUE}
# if you want to do entrezid for kegg analysis run each annotation with kegg first!

one_vs_two_entrezid <- analyzeRNA::annotate_biomart(one_vs_two,
  gmap_entrezid,
  gmattri = c("MGI_Symbol", "MGI_Desc", "EntrezID")
)

one_vs_two <- analyzeRNA::annotate_biomart(one_vs_two,
  gmap, # dont change this
  gmattri = c("MGI_Symbol", "MGI_Desc")
)

two_vs_three <- analyzeRNA::annotate_biomart(two_vs_three,
  gmap, # dont change this
  gmattri = c("MGI_Symbol", "MGI_Desc")
)

one_vs_three <- analyzeRNA::annotate_biomart(one_vs_three,
  gmap, # dont change this
  gmattri = c("MGI_Symbol", "MGI_Desc")
)
```

# Filter & sort significant DEGs

-   The list of genes returned by the `results` function of the DESeq2 package contains all the genes above a 0.1 P-value.
    This is very generous filtering, especially with so many genes and so many pairwise comparisons being done.
    The results also include some genes that have uncalculated P-values or Log2 Fold Changes due to the presence of a sample that has been detected as "an extreme outlier".
    There are also results with uncalculated adjusted P-values if there is a very low mean normalized count.

-   The `signif_deg` function will filter out these genes and only keep DEGs that meet a user specified adjusted P-value threshold and log 2 fold change threshold.

    -   In addition, it will add a `Change Direction` column to indicate if a gene is up-regulated or down-regulated in the experimental group compared to the baseline group (as specified when retrieving results above).

    -   `Change Metric` is also added to each gene and the resultant data frame will be sorted according to this.
        The metric is calculated as $Change\space Metric = \log_2(Fold \space Change) *-\log(adj.\space P \space value)$.

-   **Filter significant DEGs function inputs**

    -   `result` -\> required; the annotated results dataframe (generated above)

    -   `padj_cutoff` -\> optional; number; defaults to 0.05, the cutoff for what will be considered a signifcant p value

    -   `l2fc_cutoff` -\> optional; number; defaults to 0.8 (0.8 Log2 FC = \~1.74 FC)

    -   `entrezid` -\> optional; boolean; defaults to `FALSE`, change to `TRUE` if EntrezID is in your annotations

    -   for a gene to make it through the filter it must meet both the p value cutoff and log2 fold change cutoff

[**Change threshold values (if desired), and adjust the results data frames being generated**]{style="color: red"}

```{r signifDEG, eval=TRUE}
# set thresholds for adjusted P values and log2 fold changes in determining which genes to keep as significant
padj_threshold <- 0.05
l2fc_threshold <- 0.8

# create ranked and filtered list of dif expr genes
sig_OneTwo <- analyzeRNA::signif_deg(
  one_vs_two,
  padj_threshold,
  l2fc_threshold
)

sig_TwoThree <- analyzeRNA::signif_deg(
  two_vs_three,
  padj_threshold,
  l2fc_threshold
)

sig_OneThree <- analyzeRNA::signif_deg(
  one_vs_three,
  padj_threshold,
  l2fc_threshold
)

# if doing kegg also do the same for those
sig_OneTwo_entrezid <- analyzeRNA::signif_deg(
  one_vs_two_entrezid,
  padj_threshold,
  l2fc_threshold
)
```

This chunk will create a filtered dataframe only containing genes that reach your specified significance threshold in your specified pairwise comparisons.This will filter out genes that aren't at all different in any of the pairwise comparisons of interest.
This removes some of the noise from genes that have reads but dont change.

```{r filtered_rlogdf}
# add any/all pairwise comparisons (not the significant version) to the end of the function call
sig_rlog <- analyzeRNA::rlog_filtering(
  p_thresh = 0.1,
  fc_thresh = 0.4,
  rlogdf = rlog_df, one_vs_two, two_vs_three
)
```

# Export lists of significantly DEGs

The `export_genelist` function will save the output of the `signif_deg` function as a csv, exporting it to the current working directory.
The option to export just those genes that are up-regulated, just those that are down-regulated, or all genes is included.
You can also export a full (unfiltered) gene list if you want, but to export that do not include the direction argument.
**Do NOT include white space in the file name**

-   **Export function inputs**
    -   `tab` -\> required; dataframe; annotated (and optionally filtered) dataframe of DEGs or rLog counts
    -   `filename` -\> required; string; the name of the file to export to, it will be exported to your output dir set above, do not include ".csv" that will be added automatically, if you're exporting only up- or down-regulated genes that will be added to the file name automatically as well. avoid spaces or "-"
    -   `direction` -\> optional; string; defaults to blank; must be either `"up"`, `"down"` or left blank; if exporting rlog counts leave blank

[**Change the exports and the file names, feel free to export just up/down/both and not all three**]{style="color: red"}

```{r exportlists, eval=TRUE}
setwd(output_dir)

analyzeRNA::export_genelist(sig_OneTwo,
  filename = "1vs2",
  direction = "up"
)

analyzeRNA::export_genelist(sig_OneTwo,
  filename = "1vs2",
  direction = "down"
)

analyzeRNA::export_genelist(sig_OneTwo,
  filename = "1vs2"
)

analyzeRNA::export_genelist(one_vs_two,
  filename = "1vs2unfiltered"
)
```

------------------------------------------------------------------------

# Data visualizations

-   For the sheer amount of data in an RNAseq experiment, one of the most useful tools is data visualizations.

-   This section includes dimensionality reduction visualization techniques as well visualizations of pairwise comparisons and visualizations of expression of specific genes of interest.

-   Visualizations that use all of the samples across conditions will use the rlog normalized data.
    Visualizations showing DEGs between two conditions will use the annotated results of pairwise comparisons.

## Sample to Sample Distances

Plotting sample distances will illustrate the overall similarity between samples.
This can be compared to what is expected by the experiment design.
Rlog transformed data will be used for this to ensure that sample distance isn't overly due to certain highly expressed genes.

[**Do not edit this chunk**]{style="color: red"}

```{r sample_distances, eval=TRUE}
analyzeRNA::sample_distances(rlog_norm, anno_colors, meta)
```

## Principal Component Analysis

-   Principal component analysis (PCA) will illustrate the differences between samples as a whole, reducing the number of dimensions.
    PCA is most useful for a smaller number of samples (i.e. what we're working with in bulk RNA seq experiments, but not in single cell sequencing experiments).

-   PC1 will be the x axis and differences in PC1 are responsible for the most variance in the data set.
    The percent of variation accounted for in PC1 will be specified in the axis label.
    PC2 is the y axis and PC2 is responsible for the second most variance.
    The percent of variation here will also be included in the axis label.

-   PCA has a few major limitations.

    -   You cannot say for certain what factor or combinations of factors are contributing to the variance. However, you do get very clear insight into overall similarity and differences between samples.
    -   Inclusion of a group of samples that are vastly different than the rest will limit the information you can glean from a PCA plot. If the difference between naive samples and any treatment condition is more significant than any other differences, then you will not be able to see other differences present. To further interrogate your samples I recommend removing samples like naive from your data set and running the PCA analysis on that. This will let you see what groupings emerge without something like naive driving \~80% of the variance.
    -   For a PCA plot to really give good information, you would hope to see the principal components account for \~50-60% of the total variance. Ideally, PC1 would account for \~30+% of the variance.

-   **PCA inputs**

    -   `norm_df` -\> required; dataframe of normalized counts (ex. `rlog_df`)

    -   `plot_aes` -\> required; dataframe; the plot aesthetics set above (`plot_aes`)

    -   `metadat` -\> required, metadata dataframe

    -   `varianceRemove` -\> defaults to 0.05 which removes lowest 5% of variables based on variance.
        If there are \~2000 genes then removing 75% would leave the top 500 genes to make the PCA from

    -   `plot_title` -\> optional; string; defaults to `"Principal Component Analysis"`

    -   `draw_polygon` -\> defaults to false, if true will draw a polygon around each groups samples

    -   `draw_ellipses` -\> defaults to true, will attempt to draw an statistical ellipse around your samples

    -   `pcs` -\> a list of 2 strings that are the PCs to use, defaults to `c("PC1", "PC2")`

    -   `label_samples` -\> optional; boolean; defaults to `FALSE`; setting to `TRUE` will label as many points as possible without having too many overlaps.
        useful to ID an outlier

    -   other parameters for extra customization are available, check the help page

[**Change the title and if you want to label the dots change it to TRUE**]{style="color: red"}

```{r PCA_analysis, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/PCA_analyses.pdf"))

# run the function
# there is a ton of customizability in my fancy new code, take a peek at the function help to see what paramters you can change
analyzeRNA::pca_analysis(
  norm_df = rlog_df,
  plot_aes = plot_aes,
  metadat = meta,
  varianceRemove = 0.85,
  draw_polygon = TRUE,
  draw_ellipses = FALSE,
  label_samples = FALSE,
  pcs = c("PC1", "PC2")
)

# see how much variance is explained by each PC
p <- analyzeRNA::get_pca_obj(rlog_df, meta, 0.85)
PCAtools::screeplot(p)

# see what is contributing to each PC, this is very helpful!
PCAtools::plotloadings(p)

# comment out if you don't want to export images
grDevices::dev.off()
```

The PCA code above provides a lot of customizability.
You can also use this simple code.
This takes the top 500 genes by variance and plots the PCA using those.
This uses the built in PCA from the `DESeq2` package.
But you can't do things like see what is driving each PC or easily look at other PCs.

```{r other_pca_code}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/DEseq_PCA.pdf"))

analyzeRNA::originalPCA(
  dseq_transform = rlog_norm,
  plot_aes = plot_aes,
  plot_title = "PCA",
  label_samples = FALSE
)

# comment out if you don't want to export images
grDevices::dev.off()
```

## UMAP

-   UMAP is another dimensionality reduction technique.
    UMAP is better suited for a much higher number of samples (single cell vs bulk).
    Odds are you won't really use UMAP for anything here but I already wrote the code so I'm not getting rid of it.
    UMAP, unlike PCA does not provide you with the numerical amount of variance accounted for.

-   *Warning:* Every time the UMAP function is (re)run, the resulting plot will be different.
    This is due to "randomness" inherent in the UMAP algorithm.
    Either take steps to force reproducible results, or be cautious when re-running UMAP function.

    -   The result of the UMAP function is saved as an object so the plot can be displayed without re-calculating UMAP.
        It does not incorporate "true randomness" since computers are not capable of this.
        Functions achieve "pseudorandomness" by setting a number called a seed which changes every time the function is run.
        This number is generated using the system clock of the computer.

    -   The results can be forced to be reproducible by adding `batch = TRUE` to the umap() call, and by adding `set.seed(x)` where `x` is an integer you choose.

[**you can change the seed around, play with the neighbors and m Dist, change the title and toggle labels**]{style="color: red"}

```{r umapAnalysis, eval=FALSE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/UMAP.pdf"))


set.seed(5)
rlogUMAP <- analyzeRNA::umap_analysis(
  dseq_transform = rlog_norm,
  neighbors = 3,
  m_dist = 0.5,
  cond_list = sample_labels,
  plot_aes = plot_aes,
  plot_title = "rlog Normalized UMAP",
  batch = TRUE,
  label_samples = FALSE
)

rlogUMAP

# comment out if you don't want to export images
grDevices::dev.off()
```

## Plot counts

The counts for specific genes can be plotted by group using the normalized counts.
This can be done for specific genes of interest.
Using the `plot_genecounts` function, the data can be saved to an object for plotting.
You can check the genemap that was generated to see if a gene is in the results.
The mgi argument must be spelled exactly as it is in the genemap and is case sensitive.

-   **plot counts inputs**
    -   `mgi` -\> required; string; Must match exactly the way it's written in the MGI symbols. Check the genemap you created if you're unsure (ex. `"Tox"`, `"Pdcd1"`)
    -   `norm_df` -\> required; dataframe; the annotated rlog dataframe (`rlog_df`)
    -   `metadat` -\> required; metadata table (`meta`)
    -   `plot_aes` -\> required; same aesthetics dataframe used elsewhere
    -   `comparisons` -\> optional; list of lists of strings; defaults to an empty list; Add as many comparisons (lists of 2 strings) as you want plotted. The line will be plotted regardless of significance but p val will only be added if its significant. The order that you write them will be the order they're plotted in (vertically); `list(c("Tolerant", "Naive"), c("Tolerant", "Rejecting"), c("Naive", "Rejecting"))`
    -   `label_samples` -\> optional; boolean; defaults to `FALSE`
    -   `overlaps_allowed` -\> optional; number; defaults to `10`; This will dictate how many overlaps are tolerated when drawing the labels, make the number higher if you want to make sure more points are labeled despite being close together
    -   `yaxistozero` -\> optional; boolean; defaults to `FALSE`; if you set to TRUE the y axis will go all the way to 0. By default it'll zoom in around the counts with some space on either side
    -   `kw_hjust` -\> optional; number 0-1; defaults to `0.2`; dictates where the kruskal wallis stat is placed
    -   `kw_vjust` -\> optional; number 0-1; defaults to `1`; dictates where the kruskal wallis stat is placed
    -   `yaxis` -\> optional; string; defaults to `"rLog Normalized Reads"`; change if you want a different Y axis label

[**change the mgi symbol names & add as you wish. edit the optional variables as you wish and add comparisons as desired, the below are just examples**]{style="color: red"}

```{r plot_counts_single, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/plot_counts.pdf"))

# edit this so that its the right comparisons
statcomps <- list(
  c("Naive", "Tolerant"),
  c("Naive", "Rejection"),
  c("Tolerant", "Rejection")
)

# code for doing only one plot at a time
analyzeRNA::plot_genecounts(
  mgi = "Tox",
  norm_df = rlog_df,
  metadat = meta,
  plot_aes = plot_aes,
  label_samples = FALSE,
  comparisons = statcomps,
  yaxistozero = TRUE
)


# comment out if you don't want to export images
grDevices::dev.off()
```

The code above will allow you to plot one MGI symbol at a time. If you want to create plots for many different genes at once use this chunk
To do this, create a list of MGI symbols and the code will generate plots for all genes listed and run the mapping code to do all at once.
The other arguments in the plot will be the same for all genes in the list. If you want to change around the stat comparisons listed for each of the plots check the chunk below this one
```{r plot_counts_list}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/plot_counts2.pdf"))

# edit this so that its the right comparisons
statcomps <- list(
  c("Naive", "Tolerant"),
  c("Naive", "Rejection"),
  c("Tolerant", "Rejection")
)

# Create a list of MGI symbols that you want to create plots for.
# This must be spelled the exact way that it is in the genemap.Consult that if unsure.
# This list can be as long as you want
genes_to_plot <- list("Tox", "Pdcd1", "Batf", "Gata3")

# do not edit this code **UNLESS** you have changed the name of/are using a different rlog_df, meta, plot_aes, or statcomps or want to edit the variables otheriwse
map_genecounts <- function(i) {
  analyzeRNA::plot_genecounts(
    mgi = i,
    norm_df = rlog_df,
    metadat = meta,
    plot_aes = plot_aes,
    comparisons = statcomps,
    yaxistozero = FALSE,
    label_samples = FALSE,
    pval_format = "p.signif"
  )
}

# if you run the entire chunk with the first and last lines the plots will output to a pdf, otherwise they'll output in R
purrr::map(genes_to_plot, map_genecounts)


# comment out if you don't want to export images
grDevices::dev.off()
```

If you want to have different stats for pairwise comparisons listed for different genes that you're plotting you'll use this
You will create a list of MGI symbols the same way as above but you'll also create a separate list of comparisons.
Since each comparison is a bit unwieldy I recommend creating a few variables to cover each possible comparison you're interested in.
Then you can make a list using these variables.
The lists need to be in the same order as each other and they also must be the same length.

```{r plot_counts_list2}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/plot_counts3.pdf"))

# create your possible comparisons (include an empty list if you dont want comparisons on one of your plots)
comparison1 <- list(
  c("Naive", "Tolerant"),
  c("Naive", "Rejection"),
  c("Tolerant", "Rejection")
)

comparison2 <- list(
  c("Tolerant", "Rejection")
)

comparison3 <- list(
  c("Naive", "Tolerant"),
  c("Naive", "Rejection")
)

comparison4 <- list()

# now create a list of your comparisons that is in order corresponding to your list of gene names below.
# the two lists MUST be the same length. You can reuse comparison variables if you want the same set of comparisons but you must include it at each spot you want it
# as an example i've listed in comments which comparison matches with which gene below. Obviously if you change the lists this will no longer apply. You will need to adjust each thing so it fits your data. but make sure the orders correspond correctly
comparisons_to_plot <- list(
  comparison1, # corresponds to tox (first listed)
  comparison3, # corresponds to pdcd1
  comparison4, # corresponds to batf
  comparison4, # corresponds to gata3
  comparison2, # corresponds to jun
  comparison1, # corresponds to tigit
  comparison3 # corresponds to icos
)
# Create a list of MGI symbols that you want to create plots for.
# This must be spelled the exact way that it is in the genemap.Consult that if unsure.
# This list can be as long as you want
genes_to_plot <- list(
  "Tox", # corresponds to comparison1, (first listed)
  "Pdcd1", # corresponds to comparison3
  "Batf", # corresponds to comparison4
  "Gata3", # corresponds to comparison4
  "Jun", # corresponds to comparison2
  "Tigit", # corresponds to comparison1
  "Icos" # corresponds to comparison3
)

# do not edit this code **UNLESS** you have changed the name of/are using a different rlog_df, meta, plot_aes or want to edit the variables otheriwse
map_genecounts_with_stats <- function(mgi_symbol, stat_comparison) {
  analyzeRNA::plot_genecounts(
    mgi = mgi_symbol,
    norm_df = rlog_df,
    metadat = meta,
    plot_aes = plot_aes,
    comparisons = stat_comparison,
    yaxistozero = FALSE,
    label_samples = FALSE,
    pval_format = "p.signif"
  )
}

# if you run the entire chunk with the first and last lines the plots will output to a pdf, otherwise they'll output in R
purrr::map2(genes_to_plot, comparisons_to_plot, map_genecounts_with_stats)


# comment out if you don't want to export images
grDevices::dev.off()
```

## Volcano Plot

-   A volcano plot will show all of the genes in the pairwise comparison results

    -   the X axis on the volcano plot is the Log2 Fold Change for each gene
    -   the Y axis is the -Log10 Adjusted P value for each gene
    -   a horizontal and vertical line will be added to the plot to indicate the threshold for significance for fold change and p value respectively

-   the plot will label significant genes with their MGI symbol (not all genes may be labeled if there are too many to plot without crowding the plot)

-   **function inputs**

    -   `deg_df` -\> required; dataframe; results data frame for pairwise comparison, this should be annotated already, use the full data frame, **not** the one that has been filtered for significant genes already
    -   `plotTitle` -\> required; string; the subtitle will be condition 1 vs condition 2 automatically, I recommend titling something along the lines of `"Differentially Expressed Genes"`
    -   `cond1` -\> required; string; The first condition (numerator) in the results data frame. Must be typed how it was above (ex. `"Tolerant"`)
    -   `cond2` -\> required; string; The second condition (denominator) in the results data frame (ex. `"Naive"`)
    -   `l2fc_cutoff` -\> optional; number; defaults to `1`; where the cutoff lines will be drawn & which points will be colored (all genes are plotted)
    -   `pval_cutoff` -\> optional; number; defaults to `0.01`; where the cutoff lines will be drawn and which points will be colored
    -   `dircolors` -\> optional; list of 3 color strings; defaults to red, blue, and gray; The colors for upregulated in condition 1, downregulated in condition 1 and not significant. I recommend leaving the third as `"gray70"` or gray with any number 70-90. You can copy paste the exact color id from your plot aes dataframe if you want it to match. (ex. `c("green", "red", "gray70")`)
    -   `dirshapes` -\> optional; list of 3 numbers; defaults to all circles; The shapes for up in condition 1, down in condition 1 and not significant. (ex. `c(18, 18, 19)`)

```{r volcano_plots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/volcano_plots.pdf"))

analyzeRNA::volcano_plot(
  deg_df = one_vs_two,
  plotTitle = "One vs Two",
  cond1 = "One",
  cond2 = "Two"
)

analyzeRNA::volcano_plot(
  deg_df = two_vs_three,
  plotTitle = "Two vs Three",
  cond1 = "Two",
  cond2 = "Three",
  l2fc_cutoff = 1.5,
  pval_cutoff = 0.05,
  dircolors = c("green", "red", "gray70"),
  dirshapes = c(24, 25, 19)
)

# comment out if you don't want to export images
grDevices::dev.off()
```

## Compare two sets of DEGs from two different pairwise comparisons

Say that you want to compare the DEGs from two different pairwise comparisons - here you can plot Log2 Change vs Log2 Fold Change

```{r comparative_volcano, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/comp_volcanoplot.pdf"))

analyzeRNA::comp_volcano(
  deg_df1 = one_vs_three,
  deg_df2 = two_vs_three,
  plotTitle = "Compare these",
  conditions = c("one", "three", "two", "three"),
  l2fc_cutoff = 1.2,
  pval_cutoff = 0.35
)

# comment out if you don't want to export images
grDevices::dev.off()
```

You can use this chunk to generate a dataframe of this comparison and to export it to CSVs.
This will show you genes significantly changed between only 2 comparisons and will include those going in opposite directions.
For comparing more than 2 comparisons you can use the chunk below.

```{r compareDEGs}
setwd(output_dir)
one_two_vs_three <- analyzeRNA::compareDEGlists(
  deg_df1 = one_vs_three,
  deg_df2 = two_vs_three,
  conditions = c("one", "three", "two", "three"),
  l2fc_cutoff = 1.2, pval_cutoff = 0.35,
  export = FALSE
)

onevthree_twovfour <- analyzeRNA::compareDEGlists(
  deg_df1 = one_vs_three,
  deg_df2 = two_vs_four,
  conditions = c("one", "three", "two", "four"),
  l2fc_cutoff = 1.2, pval_cutoff = 0.35,
  export = TRUE
)
```

## Shared Genes within comaprisons

This code will generate a dataframe containing the shared significantly changed genes between 2+ pairwise comparisons.
This should use the significant dataframes.
This will only include those genes changed in the same direction.

```{r shared_genes}
one_two_shared_vs_three <- analyzeRNA::get_shared_genes(
  suffix_list = c(".one", ".two"),
  sig_OneThree,
  sig_TwoThree
)
```

## Venn Diagrams

Here you can create venn diagrams showing the \# of DEGs that are changed in multiple pairwise comparisons.
Likely, you want to have the same denominator in all the pairwise comparisons but technically it works regardless.
This should use signifianct dataframes.
You will need to input a list of the MGI symbols in each signifianct dataframe and assign it a name (see examples below).
Important to note: the shared DEGs are those that are found in both dataframes, not necessarily those that go in the same direction.
For that, use the code above, or check the dataframe exported.
You can also create a dataframe with the genes found in the intersections.

```{r venn_diagrams}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/venndiagrams.pdf"))

two_comp_venndiagram <- analyzeRNA::plot_venndiagram(list("One" = sig_OneThree$MGI_Symbol, "Two" = sig_TwoThree$MGI_Symbol),
  plt_title = "# DEGs shared vs. Three",
  edgecolor = c(group1_color, group2_color),
  showintersects = TRUE
)

three_comp_venndiagram <- analyzeRNA::plot_venndiagram(
  list(
    "One" = sig_OneThree$MGI_Symbol,
    "Two" = sig_TwoThree$MGI_Symbol,
    "Four" = sig_FourThree$MGI_Symbol
  ),
  plt_title = "# DEGs shared vs. Three",
  edgecolor = c(group1_color, group2_color, group3_color),
  showintersects = FALSE
)

# comment out if you don't want to export images
grDevices::dev.off()


overlaps_onetwo_vsthree <- analyzeRNA::venn_overlaps(list("One" = sig_OneThree$MGI_Symbol, "Two" = sig_TwoThree$MGI_Symbol))

overlaps_onetwofour_vsthree <- analyzeRNA::venn_overlaps(list(
  "One" = sig_OneThree$MGI_Symbol,
  "Two" = sig_TwoThree$MGI_Symbol,
  "Four" = sig_FourThree$MGI_Symbol
))
```

## Gene Ontology Based Analysis

[The code here was adapted from this page.](https://hbctraining.github.io/DGE_workshop/lessons/09_functional_analysis.html)

Some info on GO terms generally: [GO Terms Overview website](https://geneontology.org/docs/ontology-documentation/ "Click for background info on GO terms generally"){.uri}

GO terms are organized into "Biological Processes" (BP), "Molecular Functions" (MF), and "Cellular Components" (CC).
You can do GSEA analysis on just one of these or a combination of them.

These analyses will use pairwise comparison results, not the rlog normalized counts.

Over expression or over representation analysis is slightly different from gene set enrichment analysis.
OE analysis id's individual genes that are significantly up or down in one condition compared to another.
GSEA id's groups of genes that are enriched in one condition vs another.
GSEA is generally more powerful but both can be useful

### Over-representation Analysis

For OE/OR analysis, if you use GO (gene ontology) database you're good to go with the ensembl id (gene id column).
If you want to use the KEGG database you need to include the EntrezID in your genemap and your annotations.
KEGG ORA takes the same inputs as GO ORA except it does not include the `ontol` argument.

-   **overrepresentation inputs**
    -   `deg_df` -\> required; dataframe; annotated **unfiltered** pairwise comparisons
    -   `pval_cutoff` -\> optional; number; defaults to `0.05`
    -   `l2fc_cutoff` -\> optional defaults to `0.5`
    -   `ontol` -\> optional; string; defaults to `"ALL"`; one of `"ALL"`, `"BP"`, `"CC"`, or `"MF"` these mean including all ontologies, just biological processes, cell components, or molecular functions

### Gene Set Enrichment Analysis (GSEA)

GO and KEGG GSEA functions take the same inputs except that KEGG doesnt include the `ontol` argument.
If you're using KEGG GSEA your annotated dataframe must include EntrezID

-   **GSEA inputs**
    -   `degs` -\> required; dataframe; annotated **unfiltered** pairwise comparisons
    -   `ontol` -\> optional; string; defaults to `"ALL"`; one of `"ALL"`, `"BP"`, `"CC"`, or `"MF"` these mean including all ontologies, just biological processes, cell components, or molecular functions

```{r gsea_ora, eval=TRUE}
one_vs_two_GSEA <- analyzeRNA::go_GSEA(degs = one_vs_two, pval_cutoff = 0.05, ontol = "BP")
one_vs_two_ORA <- analyzeRNA::go_ORA(deg_df = one_vs_two, pval_cutoff = 0.05, ontol = "BP")
one_vs_two_FC <- analyzeRNA::getFoldChanges(one_vs_two)
one_vs_two_sigFC <- analyzeRNA::getFoldChanges(sig_one_vs_two)

# if you want to export the results
one_vs_two_GSEAresults <- one_vs_two_GSEA@result
setwd(output_dir)
analyzeRNA::export_genelist(one_vs_two_GSEAresults, "One_vs_two_GSEA_results")
```

### GSEA/ORA

There are many different ways to plot the results of GSEA and ORA.
Most work for both ORA and GSEA but some are only good for GSEA.
Play around with it to see how you think its best to show your data.

#### Dot plots

The dot plot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color).
This plot displays the top 50 genes by gene ratio (\# genes related to GO term / total number of sig genes), not p-adjusted value.

```{r gsea_dotplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_dot_plots.pdf"))

gseDotPlot <- makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "dot",
  categories_to_show = 35, # defaults to 30
  label_length = 65, # defaults to 75
  fontsize = 10
) # defaults to 9

gseDotPlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Ridge plots

ridge plots are a lot like dot plots but will show the enrichment distribution rather than the gene ratio.
I personally think that this is a more useful plot than the dot plot.

```{r gsea_ridgeplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_ridge_plots.pdf"))

gseRidgePlot <- makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "ridge"
)

gseRidgePlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Cluster Plot

```{r gsea_clusterplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_cluster_plots.pdf"))

gseClusterPlot <- analyzeRNA::makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "cluster"
)

gseClusterPlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Heat plot

```{r gsea_heatplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_heat_plots.pdf"), width = 50)

gseHeatPlot <- analyzeRNA::makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "heat"
)

gseHeatPlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Upset plot

```{r gsea_upsetplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_upset_plots.pdf"))

gseUpsetPlot <- analyzeRNA::makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "upset"
)

gseUpsetPlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Tree plot

```{r gsea_treeplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_tree_plots.pdf"), height = 12)

gseTreePlot <- analyzeRNA::makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "tree"
)

gseTreePlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Traditional plot

```{r gsea_tradplots, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_trad_plots.pdf"))

gseTradPlot <- analyzeRNA::makeGSEplot(
  GSE_obj = one_vs_two_GSEA,
  plot_title = "1 vs 2 GSEA",
  plot_type = "traditional"
)

gseTradPlot

# comment out if you don't want to export images
grDevices::dev.off()
```

#### Category net plot

```{r category_netplot, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_category_plots.pdf"))

catplot <- analyzeRNA::categorynetplot(
  go_obj = one_vs_two_GSEA,
  deg_df = one_vs_two,
  pval_cutoff = 0.01, # defaults to 0.05
  l2fc_cutoff = 0.8, # defaults to 0.5
  categories_to_show = 35, # defaults to 30
  shape = "circle"
) # defaults to "circle"

catplot

# comment out if you don't want to export images
grDevices::dev.off()
```

### KEGG Analysis

All of the above analysis uses the Gene Ontology annotations.
You can also perform similar analyses with KEGG pathways.
Gene Ontology (GO) pathways are split into three groups, biological processes (BP), molecular functions (MF), and cellular components (CC).
KEGG pathways are more focused on gene groups that have been associated with diseases.
For KEGG analyses you will need a dataframe that has EntrezID as a column.
If you don't already, go back up and create a second genemap & set of annotated dataframes that include EntrezID.
You should also make significant DEG dataframes but set `entrezeid = TRUE` in the `signif_deg` function.

```{r kegg}
# remember! you must use the dataframes with the EntrezID here (and not for anythin else)
```

### Revigo

From <https://revigo.irb.hr/> - this code will help you see what similar pathways are represented in your GSEA data Often, the first however many pathways that are enriched in you GSE analysis will be similar.
This can make it hard ot see the overarching pattern.
The tree map and the cluster map are very helpful for this but this code also will help.

```{r revigo}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/GSEA_revigo_plots.pdf"))

analyzeRNA::revigoPlot(
  gsea_obj = one_vs_two_GSEA,
  ontol = "BP", # one of "BP", "MF" or "CC"
  plotkind = "tree", # one of "tree", "scatter", or "heat"
  scoretype = "nes", # one of "pvalue", "qvalue", or "nes"
  plttitle = "REVIGO plot",
  sim_threshold = 0.7 # similarity threshold, for large change to 0.9, for small change to 0.5
)

# comment out if you don't want to export images
grDevices::dev.off()
```

## Heatmaps

This code chunk will create a heatmap of the most significantly changed genes across all samples and their expression in each sample.This visualization can easily show the effects of treatments on different genes.
It also will cluster genes.
These functions require the rlog_df and need it to include mgi symbol and description but no other annotations so remove any others first.

### Preparing gene sets for plotting

Using GSEA you can download relevant gene sets from the GO website as a list of just the MGI symbol.
Save them as a .CSV file in your working directory.
If you want to plot genes from a few different GO pathways that are closely related (i.e. B cell mediated immunity and Immunoglobulin mediated immune response) you can download as many as you want and then combine them using `consolidateGenelists()`.
this will return one dataframe that has all of the unqiue genes from all of your inputted CSVs.
You can also take the top x number of significantly changed genes in some comparison and then plot expression across all the groups for those.

### Heatmaps

```{r heatmap_from_csv, eval=TRUE}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/heatmaps.pdf"))

# make a heatmap from genes saved in a CSV
oxphos_heatmap <- analyzeRNA::heatmapFromCSV(
  plottitle = "Oxidative Phosphorlyation Genes",
  fname = paste(genelist_dir, "oxphos.csv", sep = "/"),
  met = meta,
  counts_df = rlog_df,
  annocolors = anno_colors,
  clusterRows = TRUE, # defaults to TRUE
  gaps = c(4, 6), # defaults to c(); insert gap this many col in, nice for separating groups
  height = 8
) # defaults to 10, decreasing will make a more squished map, better for lots of genes

oxphos_heatmap

# make a heatmap from genes from multiple CSVs
# first create a dataframe consolidating all the genelists of interest
cellprolif <- analyzeRNA::consolidate_gene_list(
  map = gmap,
  paste(genelist_dir, "cell_division.csv", "/"),
  paste(genelist_dir, "cell_proliferation.csv", "/"),
  paste(genelist_dir, "nuclear_division.csv", "/"),
  paste(genelist_dir, "chromosome_segregation.csv", "/")
)

prolif_heatmap <- analyzeRNA::heatmapFromDF(
  plottitle = "Cell Division and Proliferation",
  genelist = cellprolif,
  met = meta,
  counts_df = rlog_df,
  annocolors = anno_colors,
  clusterRows = TRUE, # defaults to TRUE
  gaps = c(3), # defaults to c()
  height = 8
) # defaults to 10

prolif_heatmap


# make a heatmap from the top x genes from whatever comparisons
# you can add or subtract depending on your comparisons
top_genes <- rbind(
  dplyr::slice_head(sig_OneTwo, n = 15) %>% dplyr::select(MGI_Symbol),
  dplyr::slice_head(sig_TwoThree, n = 15) %>% dplyr::select(MGI_Symbol)
)
top_genes <- dplyr::distinct(top_genes, MGI_Symbol, .keep_all = TRUE)

top_heatmap <- analyzeRNA::heatmapFromDF(
  plottitle = "Top 15 genes from each comparison",
  genelist = top_genes,
  met = meta,
  counts_df = rlog_df,
  annocolors = anno_colors
)


# comment out if you don't want to export images
grDevices::dev.off()
```

### Heatmap from GO pathways

```{r go_grouping_heatmaps}
# if you *don't* want the images exported to pdf, comment the line below and the final line of the chunk out. You can change the size of the images if you'd like
grDevices::pdf(file = paste0(output_dir, "/go_group_heatmaps.pdf"))

go_groups3 <- analyzeRNA::goGrouping(one_vs_two, pval_cutoff = 0.05, l2fc_cutoff = 0.45, lvl = 3)

go_groups4 <- analyzeRNA::goGrouping(one_vs_two, pval_cutoff = 0.05, l2fc_cutoff = 0.45, lvl = 4)

# get the genes in any of these go groups by the row number.

f <- analyzeRNA::genelistFromGOGroup(go_groups3, 1)
analyzeRNA::heatmapFromDF("GO Group", f, meta, rlog_df, anno_colors, gaps = c(5), height = 8)

# comment out if you don't want to export images
grDevices::dev.off()
```
